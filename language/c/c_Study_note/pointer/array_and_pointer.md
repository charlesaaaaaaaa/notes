[TOC]
# 数组与指针

## 数组与指针的关系
```
int *a, *b, c[5], d[5];
a = &c[0];
b = d;

for(int i = 0; i < 5; i++)
{
	scanf("%d, %d", &a[i], &b[i] );
}

for(int i =0; i < 5; i++)
{
	printf("%5d", *(a+i));
	printf("%5d", *(b+i));
}
```

* `a = &c[0];`和`b = d;` 都是一样的,都是把数组的第0个元素的地址给到指针变量
* `a+i`等于&a[i], 那么*(a+i)实际上就等于*&a[i],就是取`数组对应地址符的值`
  * 一个数组，每个相邻的元素占内存的地址也应该是相邻的，不会出现前一个地址3，后一个地址5的情况
  * 假设`a[0]`在内存中的地址是`1000001`, 则`&a[1]`是`1000002`，`&a[2] = 1000003`.
  * 所以可以得出`&(a+1) = &a[0] + 1 = &a[1]`

| 数组元素 | 内存中对应地址 |
|-----|-----|
| a[0] | 1000001 |
| a[1] | 1000002 |
| a[2] | 1000003 |
| a[3] | 1000004 |
| a[4] | 1000005 |
| a[5] | 1000006 |

* 我们还可以用“++”“--”的方式去修改上面的示例, 效果是一样的
```
int *a, *b, c[5], d[5];
a = &c[0];
b = d;

for(int i = 0; i < 5; i++)
{
    scanf("%d, %d", &a[i], &b[i] );
}

for(int i =0; i < 5; i++)
{
    printf("%5d", *(a++));
    printf("%5d", *(b++));
}
```
