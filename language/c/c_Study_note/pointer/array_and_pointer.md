# 数组与指针

* [数组与指针的关系](#数组与指针的关系)
  * [一维数组](#一维数组)
  * [二组数组](#二维数组)

## 数组与指针的关系
### 一维数组
```
int *a, *b, c[5], d[5];
a = &c[0];
b = d;

for(int i = 0; i < 5; i++)
{
	scanf("%d, %d", &a[i], &b[i] );
}

for(int i =0; i < 5; i++)
{
	printf("%5d", *(a+i));
	printf("%5d", *(b+i));
}
```

* `a = &c[0];`和`b = d;` 都是一样的,都是把数组的第0个元素的地址给到指针变量
* `a+i`等于&c[i], 那么*(a+i)实际上就等于*&c[i],就是取`数组对应地址符的值`
  * 一个数组，每个相邻的元素占内存的地址也应该是相邻的，不会出现前一个地址3，后一个地址5的情况
  * 假设`a[0]`在内存中的地址是`1000001`, 则`&a[1]`是`1000002`，`&a[2] = 1000003`.
  * 所以可以得出`a+1 = &c[0] + 1 = 1000001 + 1 = 1000002 = &c[1]`

| 数组元素 | 内存中对应地址 |
|-----|-----|
| a[0] | 1000001 |
| a[1] | 1000002 |
| a[2] | 1000003 |
| a[3] | 1000004 |
| a[4] | 1000005 |
| a[5] | 1000006 |

* 我们还可以用“++”“--”的方式去修改上面的示例, 效果是一样的
```
int *a, *b, c[5], d[5];
a = &c[0];
b = d;

for(int i = 0; i < 5; i++)
{
    scanf("%d, %d", a++, b++ );
}
a = c;
b =d;
for(int i =0; i < 5; i++)
{
    printf("%5d", *(a++));
    printf("%5d", *(b++));
}
```
  * 定义指针变量时，`a = &c[0]`,所以在使用scanf时，指针变量前面不用再加&了
    * 因为指针变量指向的变量地址已经带有&了
  * 然后就是直接使用a++的形式去scanf，那么我们在printf时要先初始化一下指针变量
    * 因为开头定义的指针变量不属于scanf对应的for的局部变量，而是for上一级的局部变量
	* 那么这个时候直接p++，会直接影响到上一级的指针变量p
	* 所以在printf时再a++，实际上就是&c[4]++, 100005 + 1就是c[5]所在的地址符
	* 然而我们并没有定义c[5],所以编译时会直接出现错误
	  * 上一个示例是直接调用的c[i], 所以并不会影响到后面printf的*(a+i), 故不需要初始化指针变量

### 二维数组

* 二维数组在被赋值时，也是将某行的首个地址赋给指针变量
  * `a = &c[0]`
  * `a = &c[2]`
* 想要使用已经增值二维数组的指针变量，应该使用
  * `printf("%d", *(*(a+i)+j)`
  * 其中*(a+i)就是 **指针a的地址值加上i，然后再取其对应地址的值**,相当于取c[i]这一行
  * *(*(a+i)+j)相当于取c[i][j]的值

